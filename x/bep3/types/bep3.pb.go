// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: nemo/bep3/v1beta1/bep3.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	github_com_tendermint_tendermint_libs_bytes "github.com/tendermint/tendermint/libs/bytes"
	_ "google.golang.org/protobuf/types/known/durationpb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// SwapStatus is the status of an AtomicSwap
type SwapStatus int32

const (
	// SWAP_STATUS_UNSPECIFIED represents an unspecified status
	SWAP_STATUS_UNSPECIFIED SwapStatus = 0
	// SWAP_STATUS_OPEN represents an open swap
	SWAP_STATUS_OPEN SwapStatus = 1
	// SWAP_STATUS_COMPLETED represents a completed swap
	SWAP_STATUS_COMPLETED SwapStatus = 2
	// SWAP_STATUS_EXPIRED represents an expired swap
	SWAP_STATUS_EXPIRED SwapStatus = 3
)

var SwapStatus_name = map[int32]string{
	0: "SWAP_STATUS_UNSPECIFIED",
	1: "SWAP_STATUS_OPEN",
	2: "SWAP_STATUS_COMPLETED",
	3: "SWAP_STATUS_EXPIRED",
}

var SwapStatus_value = map[string]int32{
	"SWAP_STATUS_UNSPECIFIED": 0,
	"SWAP_STATUS_OPEN":        1,
	"SWAP_STATUS_COMPLETED":   2,
	"SWAP_STATUS_EXPIRED":     3,
}

func (x SwapStatus) String() string {
	return proto.EnumName(SwapStatus_name, int32(x))
}

func (SwapStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3802e4b2452359ee, []int{0}
}

// SwapDirection is the direction of an AtomicSwap
type SwapDirection int32

const (
	// SWAP_DIRECTION_UNSPECIFIED represents unspecified or invalid swap direcation
	SWAP_DIRECTION_UNSPECIFIED SwapDirection = 0
	// SWAP_DIRECTION_INCOMING represents is incoming swap (to the nemo chain)
	SWAP_DIRECTION_INCOMING SwapDirection = 1
	// SWAP_DIRECTION_OUTGOING represents an outgoing swap (from the nemo chain)
	SWAP_DIRECTION_OUTGOING SwapDirection = 2
)

var SwapDirection_name = map[int32]string{
	0: "SWAP_DIRECTION_UNSPECIFIED",
	1: "SWAP_DIRECTION_INCOMING",
	2: "SWAP_DIRECTION_OUTGOING",
}

var SwapDirection_value = map[string]int32{
	"SWAP_DIRECTION_UNSPECIFIED": 0,
	"SWAP_DIRECTION_INCOMING":    1,
	"SWAP_DIRECTION_OUTGOING":    2,
}

func (x SwapDirection) String() string {
	return proto.EnumName(SwapDirection_name, int32(x))
}

func (SwapDirection) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3802e4b2452359ee, []int{1}
}

// Params defines the parameters for the bep3 module.
type Params struct {
	// asset_params define the parameters for each bep3 asset
	AssetParams AssetParams `protobuf:"bytes,1,rep,name=asset_params,json=assetParams,proto3,castrepeated=AssetParams" json:"asset_params"`
}

func (m *Params) Reset()         { *m = Params{} }
func (m *Params) String() string { return proto.CompactTextString(m) }
func (*Params) ProtoMessage()    {}
func (*Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_3802e4b2452359ee, []int{0}
}
func (m *Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Params.Merge(m, src)
}
func (m *Params) XXX_Size() int {
	return m.Size()
}
func (m *Params) XXX_DiscardUnknown() {
	xxx_messageInfo_Params.DiscardUnknown(m)
}

var xxx_messageInfo_Params proto.InternalMessageInfo

func (m *Params) GetAssetParams() AssetParams {
	if m != nil {
		return m.AssetParams
	}
	return nil
}

// AssetParam defines parameters for each bep3 asset.
type AssetParam struct {
	// denom represents the denominatin for this asset
	Denom string `protobuf:"bytes,1,opt,name=denom,proto3" json:"denom,omitempty"`
	// coin_id represents the registered coin type to use (https://github.com/satoshilabs/slips/blob/master/slip-0044.md)
	CoinID int64 `protobuf:"varint,2,opt,name=coin_id,json=coinId,proto3" json:"coin_id,omitempty"`
	// supply_limit defines the maximum supply allowed for the asset - a total or time based rate limit
	SupplyLimit SupplyLimit `protobuf:"bytes,3,opt,name=supply_limit,json=supplyLimit,proto3" json:"supply_limit"`
	// active specifies if the asset is live or paused
	Active bool `protobuf:"varint,4,opt,name=active,proto3" json:"active,omitempty"`
	// deputy_address the nemo address of the deputy
	DeputyAddress github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,5,opt,name=deputy_address,json=deputyAddress,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"deputy_address,omitempty"`
	// fixed_fee defines the fee for incoming swaps
	FixedFee github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,6,opt,name=fixed_fee,json=fixedFee,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"fixed_fee"`
	// min_swap_amount defines the minimum amount able to be swapped in a single message
	MinSwapAmount github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,7,opt,name=min_swap_amount,json=minSwapAmount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"min_swap_amount"`
	// max_swap_amount defines the maximum amount able to be swapped in a single message
	MaxSwapAmount github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,8,opt,name=max_swap_amount,json=maxSwapAmount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"max_swap_amount"`
	// min_block_lock defined the minimum blocks to lock
	MinBlockLock uint64 `protobuf:"varint,9,opt,name=min_block_lock,json=minBlockLock,proto3" json:"min_block_lock,omitempty"`
	// min_block_lock defined the maximum blocks to lock
	MaxBlockLock uint64 `protobuf:"varint,10,opt,name=max_block_lock,json=maxBlockLock,proto3" json:"max_block_lock,omitempty"`
}

func (m *AssetParam) Reset()         { *m = AssetParam{} }
func (m *AssetParam) String() string { return proto.CompactTextString(m) }
func (*AssetParam) ProtoMessage()    {}
func (*AssetParam) Descriptor() ([]byte, []int) {
	return fileDescriptor_3802e4b2452359ee, []int{1}
}
func (m *AssetParam) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AssetParam) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AssetParam.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AssetParam) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AssetParam.Merge(m, src)
}
func (m *AssetParam) XXX_Size() int {
	return m.Size()
}
func (m *AssetParam) XXX_DiscardUnknown() {
	xxx_messageInfo_AssetParam.DiscardUnknown(m)
}

var xxx_messageInfo_AssetParam proto.InternalMessageInfo

func (m *AssetParam) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *AssetParam) GetCoinID() int64 {
	if m != nil {
		return m.CoinID
	}
	return 0
}

func (m *AssetParam) GetSupplyLimit() SupplyLimit {
	if m != nil {
		return m.SupplyLimit
	}
	return SupplyLimit{}
}

func (m *AssetParam) GetActive() bool {
	if m != nil {
		return m.Active
	}
	return false
}

func (m *AssetParam) GetDeputyAddress() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.DeputyAddress
	}
	return nil
}

func (m *AssetParam) GetMinBlockLock() uint64 {
	if m != nil {
		return m.MinBlockLock
	}
	return 0
}

func (m *AssetParam) GetMaxBlockLock() uint64 {
	if m != nil {
		return m.MaxBlockLock
	}
	return 0
}

// SupplyLimit define the absolute and time-based limits for an assets's supply.
type SupplyLimit struct {
	// limit defines the total supply allowed
	Limit github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,1,opt,name=limit,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"limit"`
	// time_limited enables or disables time based supply limiting
	TimeLimited bool `protobuf:"varint,2,opt,name=time_limited,json=timeLimited,proto3" json:"time_limited,omitempty"`
	// time_period specifies the duration that time_based_limit is evalulated
	TimePeriod time.Duration `protobuf:"bytes,3,opt,name=time_period,json=timePeriod,proto3,stdduration" json:"time_period"`
	// time_based_limit defines the maximum supply that can be swapped within time_period
	TimeBasedLimit github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,4,opt,name=time_based_limit,json=timeBasedLimit,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"time_based_limit"`
}

func (m *SupplyLimit) Reset()         { *m = SupplyLimit{} }
func (m *SupplyLimit) String() string { return proto.CompactTextString(m) }
func (*SupplyLimit) ProtoMessage()    {}
func (*SupplyLimit) Descriptor() ([]byte, []int) {
	return fileDescriptor_3802e4b2452359ee, []int{2}
}
func (m *SupplyLimit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SupplyLimit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SupplyLimit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SupplyLimit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SupplyLimit.Merge(m, src)
}
func (m *SupplyLimit) XXX_Size() int {
	return m.Size()
}
func (m *SupplyLimit) XXX_DiscardUnknown() {
	xxx_messageInfo_SupplyLimit.DiscardUnknown(m)
}

var xxx_messageInfo_SupplyLimit proto.InternalMessageInfo

func (m *SupplyLimit) GetTimeLimited() bool {
	if m != nil {
		return m.TimeLimited
	}
	return false
}

func (m *SupplyLimit) GetTimePeriod() time.Duration {
	if m != nil {
		return m.TimePeriod
	}
	return 0
}

// AtomicSwap defines an atomic swap between chains for the pricefeed module.
type AtomicSwap struct {
	// amount represents the amount being swapped
	Amount github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,1,rep,name=amount,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"amount"`
	// random_number_hash represents the hash of the random number
	RandomNumberHash github_com_tendermint_tendermint_libs_bytes.HexBytes `protobuf:"bytes,2,opt,name=random_number_hash,json=randomNumberHash,proto3,casttype=github.com/tendermint/tendermint/libs/bytes.HexBytes" json:"random_number_hash,omitempty"`
	// expire_height represents the height when the swap expires
	ExpireHeight uint64 `protobuf:"varint,3,opt,name=expire_height,json=expireHeight,proto3" json:"expire_height,omitempty"`
	// timestamp represents the timestamp of the swap
	Timestamp int64 `protobuf:"varint,4,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// sender is the nemo chain sender of the swap
	Sender github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,5,opt,name=sender,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"sender,omitempty"`
	// recipient is the nemo chain recipient of the swap
	Recipient github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,6,opt,name=recipient,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"recipient,omitempty"`
	// sender_other_chain is the sender on the other chain
	SenderOtherChain string `protobuf:"bytes,7,opt,name=sender_other_chain,json=senderOtherChain,proto3" json:"sender_other_chain,omitempty"`
	// recipient_other_chain is the recipient on the other chain
	RecipientOtherChain string `protobuf:"bytes,8,opt,name=recipient_other_chain,json=recipientOtherChain,proto3" json:"recipient_other_chain,omitempty"`
	// closed_block is the block when the swap is closed
	ClosedBlock int64 `protobuf:"varint,9,opt,name=closed_block,json=closedBlock,proto3" json:"closed_block,omitempty"`
	// status represents the current status of the swap
	Status SwapStatus `protobuf:"varint,10,opt,name=status,proto3,enum=nemo.bep3.v1beta1.SwapStatus" json:"status,omitempty"`
	// cross_chain identifies whether the atomic swap is cross chain
	CrossChain bool `protobuf:"varint,11,opt,name=cross_chain,json=crossChain,proto3" json:"cross_chain,omitempty"`
	// direction identifies if the swap is incoming or outgoing
	Direction SwapDirection `protobuf:"varint,12,opt,name=direction,proto3,enum=nemo.bep3.v1beta1.SwapDirection" json:"direction,omitempty"`
}

func (m *AtomicSwap) Reset()         { *m = AtomicSwap{} }
func (m *AtomicSwap) String() string { return proto.CompactTextString(m) }
func (*AtomicSwap) ProtoMessage()    {}
func (*AtomicSwap) Descriptor() ([]byte, []int) {
	return fileDescriptor_3802e4b2452359ee, []int{3}
}
func (m *AtomicSwap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AtomicSwap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AtomicSwap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AtomicSwap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AtomicSwap.Merge(m, src)
}
func (m *AtomicSwap) XXX_Size() int {
	return m.Size()
}
func (m *AtomicSwap) XXX_DiscardUnknown() {
	xxx_messageInfo_AtomicSwap.DiscardUnknown(m)
}

var xxx_messageInfo_AtomicSwap proto.InternalMessageInfo

func (m *AtomicSwap) GetAmount() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.Amount
	}
	return nil
}

func (m *AtomicSwap) GetRandomNumberHash() github_com_tendermint_tendermint_libs_bytes.HexBytes {
	if m != nil {
		return m.RandomNumberHash
	}
	return nil
}

func (m *AtomicSwap) GetExpireHeight() uint64 {
	if m != nil {
		return m.ExpireHeight
	}
	return 0
}

func (m *AtomicSwap) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *AtomicSwap) GetSender() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Sender
	}
	return nil
}

func (m *AtomicSwap) GetRecipient() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Recipient
	}
	return nil
}

func (m *AtomicSwap) GetSenderOtherChain() string {
	if m != nil {
		return m.SenderOtherChain
	}
	return ""
}

func (m *AtomicSwap) GetRecipientOtherChain() string {
	if m != nil {
		return m.RecipientOtherChain
	}
	return ""
}

func (m *AtomicSwap) GetClosedBlock() int64 {
	if m != nil {
		return m.ClosedBlock
	}
	return 0
}

func (m *AtomicSwap) GetStatus() SwapStatus {
	if m != nil {
		return m.Status
	}
	return SWAP_STATUS_UNSPECIFIED
}

func (m *AtomicSwap) GetCrossChain() bool {
	if m != nil {
		return m.CrossChain
	}
	return false
}

func (m *AtomicSwap) GetDirection() SwapDirection {
	if m != nil {
		return m.Direction
	}
	return SWAP_DIRECTION_UNSPECIFIED
}

// AssetSupply defines information about an asset's supply.
type AssetSupply struct {
	// incoming_supply represents the incoming supply of an asset
	IncomingSupply types.Coin `protobuf:"bytes,1,opt,name=incoming_supply,json=incomingSupply,proto3" json:"incoming_supply"`
	// outgoing_supply represents the outgoing supply of an asset
	OutgoingSupply types.Coin `protobuf:"bytes,2,opt,name=outgoing_supply,json=outgoingSupply,proto3" json:"outgoing_supply"`
	// current_supply represents the current on-chain supply of an asset
	CurrentSupply types.Coin `protobuf:"bytes,3,opt,name=current_supply,json=currentSupply,proto3" json:"current_supply"`
	// time_limited_current_supply represents the time limited current supply of an asset
	TimeLimitedCurrentSupply types.Coin `protobuf:"bytes,4,opt,name=time_limited_current_supply,json=timeLimitedCurrentSupply,proto3" json:"time_limited_current_supply"`
	// time_elapsed represents the time elapsed
	TimeElapsed time.Duration `protobuf:"bytes,5,opt,name=time_elapsed,json=timeElapsed,proto3,stdduration" json:"time_elapsed"`
}

func (m *AssetSupply) Reset()         { *m = AssetSupply{} }
func (m *AssetSupply) String() string { return proto.CompactTextString(m) }
func (*AssetSupply) ProtoMessage()    {}
func (*AssetSupply) Descriptor() ([]byte, []int) {
	return fileDescriptor_3802e4b2452359ee, []int{4}
}
func (m *AssetSupply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AssetSupply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AssetSupply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AssetSupply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AssetSupply.Merge(m, src)
}
func (m *AssetSupply) XXX_Size() int {
	return m.Size()
}
func (m *AssetSupply) XXX_DiscardUnknown() {
	xxx_messageInfo_AssetSupply.DiscardUnknown(m)
}

var xxx_messageInfo_AssetSupply proto.InternalMessageInfo

func (m *AssetSupply) GetIncomingSupply() types.Coin {
	if m != nil {
		return m.IncomingSupply
	}
	return types.Coin{}
}

func (m *AssetSupply) GetOutgoingSupply() types.Coin {
	if m != nil {
		return m.OutgoingSupply
	}
	return types.Coin{}
}

func (m *AssetSupply) GetCurrentSupply() types.Coin {
	if m != nil {
		return m.CurrentSupply
	}
	return types.Coin{}
}

func (m *AssetSupply) GetTimeLimitedCurrentSupply() types.Coin {
	if m != nil {
		return m.TimeLimitedCurrentSupply
	}
	return types.Coin{}
}

func (m *AssetSupply) GetTimeElapsed() time.Duration {
	if m != nil {
		return m.TimeElapsed
	}
	return 0
}

func init() {
	proto.RegisterEnum("nemo.bep3.v1beta1.SwapStatus", SwapStatus_name, SwapStatus_value)
	proto.RegisterEnum("nemo.bep3.v1beta1.SwapDirection", SwapDirection_name, SwapDirection_value)
	proto.RegisterType((*Params)(nil), "nemo.bep3.v1beta1.Params")
	proto.RegisterType((*AssetParam)(nil), "nemo.bep3.v1beta1.AssetParam")
	proto.RegisterType((*SupplyLimit)(nil), "nemo.bep3.v1beta1.SupplyLimit")
	proto.RegisterType((*AtomicSwap)(nil), "nemo.bep3.v1beta1.AtomicSwap")
	proto.RegisterType((*AssetSupply)(nil), "nemo.bep3.v1beta1.AssetSupply")
}

func init() { proto.RegisterFile("nemo/bep3/v1beta1/bep3.proto", fileDescriptor_3802e4b2452359ee) }

var fileDescriptor_3802e4b2452359ee = []byte{
	// 1157 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x56, 0x4d, 0x6f, 0x1a, 0x57,
	0x17, 0xf6, 0x18, 0x4c, 0xec, 0x03, 0x26, 0xbc, 0xd7, 0xc9, 0x1b, 0xec, 0xa4, 0x40, 0x9c, 0xaa,
	0x42, 0x69, 0x0d, 0x4d, 0xd2, 0x4a, 0x5d, 0x54, 0x95, 0x18, 0xc0, 0x31, 0x92, 0x03, 0x68, 0xb0,
	0xd5, 0x8f, 0x45, 0xa7, 0xc3, 0xcc, 0x05, 0xae, 0xcc, 0xcc, 0x1d, 0xcd, 0xbd, 0x24, 0x78, 0xdd,
	0x4d, 0x17, 0x5d, 0xb4, 0xbb, 0xee, 0xbb, 0xeb, 0xb2, 0xca, 0x8f, 0xc8, 0x32, 0xca, 0xaa, 0xea,
	0xc2, 0xa9, 0x9c, 0x7f, 0x91, 0x55, 0x75, 0x3f, 0x0c, 0xe3, 0xd4, 0xad, 0x58, 0xb0, 0xb1, 0x39,
	0x1f, 0xcf, 0x73, 0xce, 0xdc, 0x39, 0xe7, 0xb9, 0x03, 0x77, 0x02, 0xec, 0xd3, 0x6a, 0x1f, 0x87,
	0x8f, 0xaa, 0x4f, 0x1f, 0xf4, 0x31, 0x77, 0x1e, 0x48, 0xa3, 0x12, 0x46, 0x94, 0x53, 0xf4, 0x3f,
	0x11, 0xad, 0x48, 0x87, 0x8e, 0xee, 0x14, 0x5c, 0xca, 0x7c, 0xca, 0xaa, 0x7d, 0x87, 0xe1, 0x19,
	0xc4, 0xa5, 0x24, 0x50, 0x90, 0x9d, 0x6d, 0x15, 0xb7, 0xa5, 0x55, 0x55, 0x86, 0x0e, 0xdd, 0x18,
	0xd2, 0x21, 0x55, 0x7e, 0xf1, 0x4b, 0x7b, 0x0b, 0x43, 0x4a, 0x87, 0x63, 0x5c, 0x95, 0x56, 0x7f,
	0x32, 0xa8, 0x7a, 0x93, 0xc8, 0xe1, 0x84, 0x6a, 0xc2, 0x5d, 0x1b, 0x52, 0x5d, 0x27, 0x72, 0x7c,
	0x86, 0x8e, 0x21, 0xe3, 0x30, 0x86, 0xb9, 0x1d, 0x4a, 0x3b, 0x6f, 0x94, 0x12, 0xe5, 0xf4, 0xc3,
	0xf7, 0x2a, 0xff, 0x68, 0xb2, 0x52, 0x13, 0x69, 0x12, 0x65, 0x6e, 0xbd, 0x38, 0x2b, 0xae, 0xfc,
	0xf6, 0xba, 0x98, 0x9e, 0xfb, 0x98, 0x95, 0x76, 0xe6, 0xc6, 0xee, 0x8f, 0x6b, 0x00, 0xf3, 0x20,
	0xba, 0x01, 0x6b, 0x1e, 0x0e, 0xa8, 0x9f, 0x37, 0x4a, 0x46, 0x79, 0xc3, 0x52, 0x06, 0xba, 0x07,
	0xd7, 0xc4, 0x43, 0xda, 0xc4, 0xcb, 0xaf, 0x96, 0x8c, 0x72, 0xc2, 0x84, 0xf3, 0xb3, 0x62, 0xaa,
	0x4e, 0x49, 0xd0, 0x6a, 0x58, 0x29, 0x11, 0x6a, 0x79, 0xe8, 0x31, 0x64, 0xd8, 0x24, 0x0c, 0xc7,
	0xa7, 0xf6, 0x98, 0xf8, 0x84, 0xe7, 0x13, 0x25, 0xa3, 0x9c, 0x7e, 0x58, 0xb8, 0xa2, 0xc1, 0x9e,
	0x4c, 0x3b, 0x14, 0x59, 0x66, 0x52, 0x74, 0x68, 0xa5, 0xd9, 0xdc, 0x85, 0xfe, 0x0f, 0x29, 0xc7,
	0xe5, 0xe4, 0x29, 0xce, 0x27, 0x4b, 0x46, 0x79, 0xdd, 0xd2, 0x16, 0xa2, 0x90, 0xf5, 0x70, 0x38,
	0xe1, 0xa7, 0xb6, 0xe3, 0x79, 0x11, 0x66, 0x2c, 0xbf, 0x56, 0x32, 0xca, 0x19, 0xf3, 0xe0, 0xed,
	0x59, 0x71, 0x6f, 0x48, 0xf8, 0x68, 0xd2, 0xaf, 0xb8, 0xd4, 0xd7, 0xc7, 0xae, 0xff, 0xed, 0x31,
	0xef, 0xa4, 0xca, 0x4f, 0x43, 0xcc, 0x2a, 0x35, 0xd7, 0xad, 0x29, 0xe0, 0xab, 0xe7, 0x7b, 0x5b,
	0xfa, 0xe5, 0x68, 0x8f, 0x79, 0xca, 0x31, 0xb3, 0x36, 0x15, 0xbf, 0xf6, 0xa1, 0xaf, 0x61, 0x63,
	0x40, 0xa6, 0xd8, 0xb3, 0x07, 0x18, 0xe7, 0x53, 0xe2, 0x40, 0xcc, 0xcf, 0x45, 0xbb, 0x7f, 0x9e,
	0x15, 0x3f, 0x58, 0xa0, 0x5e, 0x2b, 0xe0, 0xaf, 0x9e, 0xef, 0x81, 0x2e, 0xd4, 0x0a, 0xb8, 0xb5,
	0x2e, 0xe9, 0xf6, 0x31, 0x46, 0x1e, 0x5c, 0xf7, 0x49, 0x60, 0xb3, 0x67, 0x4e, 0x68, 0x3b, 0x3e,
	0x9d, 0x04, 0x3c, 0x7f, 0x6d, 0x09, 0x05, 0x36, 0x7d, 0x12, 0xf4, 0x9e, 0x39, 0x61, 0x4d, 0x52,
	0xca, 0x2a, 0xce, 0xf4, 0x52, 0x95, 0xf5, 0xa5, 0x54, 0x71, 0xa6, 0xb1, 0x2a, 0xef, 0x43, 0x56,
	0x3c, 0x4b, 0x7f, 0x4c, 0xdd, 0x13, 0x5b, 0xfc, 0xc9, 0x6f, 0x94, 0x8c, 0x72, 0xd2, 0xca, 0xf8,
	0x24, 0x30, 0x85, 0x7d, 0x48, 0xdd, 0x13, 0x99, 0xe5, 0x4c, 0xe3, 0x59, 0xa0, 0xb3, 0x9c, 0xe9,
	0x2c, 0x6b, 0xf7, 0xf7, 0x55, 0x48, 0xc7, 0xc6, 0x03, 0x59, 0xb0, 0xa6, 0xa6, 0xc9, 0x58, 0x42,
	0xdf, 0x8a, 0x0a, 0xdd, 0x85, 0x0c, 0x27, 0x3e, 0x56, 0x63, 0x8a, 0xd5, 0x48, 0xaf, 0x5b, 0x69,
	0xe1, 0x3b, 0x54, 0x2e, 0xd4, 0x00, 0x69, 0xda, 0x21, 0x8e, 0x08, 0xf5, 0xf4, 0x28, 0x6f, 0x57,
	0xd4, 0xb2, 0x56, 0x2e, 0x96, 0xb5, 0xd2, 0xd0, 0xcb, 0x6a, 0xae, 0x8b, 0xbe, 0x7e, 0x79, 0x5d,
	0x34, 0x2c, 0x10, 0xb8, 0xae, 0x84, 0xa1, 0x01, 0xe4, 0x24, 0x8b, 0x50, 0x0b, 0x4f, 0x6f, 0x45,
	0x72, 0x09, 0xcf, 0x91, 0x15, 0xac, 0xa6, 0x20, 0x95, 0xfd, 0xee, 0x7e, 0x9f, 0x02, 0xa8, 0x71,
	0xea, 0x13, 0x57, 0xbc, 0x15, 0xe4, 0x42, 0x4a, 0xbf, 0x6c, 0xa5, 0x11, 0xdb, 0x15, 0x8d, 0x15,
	0x7d, 0xcc, 0x96, 0x50, 0x6c, 0xaf, 0xf9, 0xb1, 0xd6, 0x87, 0xf2, 0x02, 0x7d, 0x08, 0x00, 0xb3,
	0x34, 0x35, 0x1a, 0x00, 0x8a, 0x9c, 0xc0, 0xa3, 0xbe, 0x1d, 0x4c, 0xfc, 0x3e, 0x8e, 0xec, 0x91,
	0xc3, 0x46, 0xf2, 0x28, 0x33, 0xe6, 0x67, 0x6f, 0xcf, 0x8a, 0x9f, 0xc4, 0x18, 0x39, 0x0e, 0x3c,
	0x1c, 0xf9, 0x24, 0xe0, 0xf1, 0x9f, 0x63, 0xd2, 0x67, 0xd5, 0xbe, 0xd8, 0xbb, 0xca, 0x01, 0x9e,
	0xaa, 0x05, 0xcc, 0x29, 0xce, 0xb6, 0xa4, 0x3c, 0x70, 0xd8, 0x08, 0xdd, 0x83, 0x4d, 0x3c, 0x0d,
	0x49, 0x84, 0xed, 0x11, 0x26, 0xc3, 0x91, 0x92, 0x95, 0xa4, 0x95, 0x51, 0xce, 0x03, 0xe9, 0x43,
	0x77, 0x60, 0x43, 0x1c, 0x09, 0xe3, 0x8e, 0x1f, 0xca, 0x13, 0x4e, 0x58, 0x73, 0x07, 0xfa, 0x0e,
	0x52, 0x4c, 0x96, 0x5d, 0xba, 0x5e, 0x68, 0x5e, 0x34, 0x80, 0x8d, 0x08, 0xbb, 0x24, 0x24, 0x38,
	0xe0, 0x52, 0x28, 0x96, 0x59, 0x64, 0x4e, 0x8d, 0x3e, 0x02, 0xa4, 0x2a, 0xda, 0x94, 0x8f, 0x70,
	0x64, 0xbb, 0x23, 0x87, 0x04, 0x4a, 0x38, 0xac, 0x9c, 0x8a, 0x74, 0x44, 0xa0, 0x2e, 0xfc, 0xe8,
	0x21, 0xdc, 0x9c, 0x41, 0x2f, 0x01, 0xa4, 0x06, 0x58, 0x5b, 0xb3, 0x60, 0x0c, 0x73, 0x17, 0x32,
	0xee, 0x98, 0x8a, 0x71, 0xed, 0xcf, 0x36, 0x39, 0x61, 0xa5, 0x95, 0x4f, 0xae, 0x29, 0xfa, 0x14,
	0x52, 0x8c, 0x3b, 0x7c, 0xc2, 0xe4, 0x02, 0x67, 0xaf, 0xbc, 0x82, 0xc4, 0x1c, 0xf6, 0x64, 0x92,
	0xa5, 0x93, 0x51, 0x11, 0xd2, 0x6e, 0x44, 0x19, 0xd3, 0x3d, 0xa4, 0xe5, 0xd2, 0x81, 0x74, 0xa9,
	0xd2, 0x5f, 0xc0, 0x86, 0x47, 0x22, 0xec, 0x8a, 0x85, 0xca, 0x67, 0x24, 0x75, 0xe9, 0x5f, 0xa8,
	0x1b, 0x17, 0x79, 0xd6, 0x1c, 0xb2, 0xfb, 0x73, 0x02, 0xd4, 0x35, 0xa7, 0xf4, 0x03, 0x1d, 0xc0,
	0x75, 0x12, 0xb8, 0xd4, 0x27, 0xc1, 0xd0, 0x56, 0xd7, 0x8b, 0x14, 0x91, 0xff, 0xdc, 0x07, 0x75,
	0x1b, 0x65, 0x2f, 0x70, 0x73, 0x26, 0x3a, 0xe1, 0x43, 0x1a, 0x63, 0x5a, 0x5d, 0x90, 0xe9, 0x02,
	0xa7, 0x99, 0xf6, 0x21, 0xeb, 0x4e, 0xa2, 0x48, 0xbc, 0x10, 0x4d, 0x94, 0x58, 0x8c, 0x68, 0x53,
	0xc3, 0x34, 0xcf, 0xb7, 0x70, 0x3b, 0x2e, 0x61, 0xf6, 0x3b, 0xa4, 0xc9, 0xc5, 0x48, 0xf3, 0x31,
	0xc9, 0xab, 0x5f, 0xe2, 0xdf, 0xd7, 0x12, 0x89, 0xc7, 0x4e, 0xc8, 0xb0, 0x27, 0x17, 0x67, 0x41,
	0x01, 0x94, 0xc2, 0xd9, 0x54, 0xb8, 0xfb, 0xa7, 0x00, 0xf3, 0x51, 0x40, 0xb7, 0xe1, 0x56, 0xef,
	0xcb, 0x5a, 0xd7, 0xee, 0x1d, 0xd5, 0x8e, 0x8e, 0x7b, 0xf6, 0x71, 0xbb, 0xd7, 0x6d, 0xd6, 0x5b,
	0xfb, 0xad, 0x66, 0x23, 0xb7, 0x82, 0x6e, 0x40, 0x2e, 0x1e, 0xec, 0x74, 0x9b, 0xed, 0x9c, 0x81,
	0xb6, 0xe1, 0x66, 0xdc, 0x5b, 0xef, 0x3c, 0xe9, 0x1e, 0x36, 0x8f, 0x9a, 0x8d, 0xdc, 0x2a, 0xba,
	0x05, 0x5b, 0xf1, 0x50, 0xf3, 0xab, 0x6e, 0xcb, 0x6a, 0x36, 0x72, 0x89, 0x9d, 0xe4, 0x0f, 0xbf,
	0x16, 0x56, 0xee, 0x53, 0xd8, 0xbc, 0x34, 0x2a, 0xa8, 0x00, 0x3b, 0x32, 0xbf, 0xd1, 0xb2, 0x9a,
	0xf5, 0xa3, 0x56, 0xa7, 0xfd, 0x4e, 0x03, 0x17, 0xdd, 0xcd, 0xe3, 0xad, 0x76, 0xbd, 0xf3, 0xa4,
	0xd5, 0x7e, 0x9c, 0x33, 0xae, 0x08, 0x76, 0x8e, 0x8f, 0x1e, 0x77, 0x44, 0x70, 0x55, 0x15, 0x34,
	0x9b, 0x2f, 0xce, 0x0b, 0xc6, 0xcb, 0xf3, 0x82, 0xf1, 0xd7, 0x79, 0xc1, 0xf8, 0xe9, 0x4d, 0x61,
	0xe5, 0xe5, 0x9b, 0xc2, 0xca, 0x1f, 0x6f, 0x0a, 0x2b, 0xdf, 0x7c, 0x18, 0xd3, 0x01, 0x1f, 0x47,
	0x63, 0x12, 0xec, 0x05, 0x98, 0x3f, 0xa3, 0xd1, 0x49, 0x55, 0x7e, 0x80, 0x4e, 0xd5, 0x27, 0xa8,
	0x14, 0x84, 0x7e, 0x4a, 0x1e, 0xee, 0xa3, 0xbf, 0x03, 0x00, 0x00, 0xff, 0xff, 0x8c, 0x90, 0x51,
	0x6b, 0x9c, 0x0a, 0x00, 0x00,
}

func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AssetParams) > 0 {
		for iNdEx := len(m.AssetParams) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AssetParams[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBep3(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AssetParam) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AssetParam) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AssetParam) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxBlockLock != 0 {
		i = encodeVarintBep3(dAtA, i, uint64(m.MaxBlockLock))
		i--
		dAtA[i] = 0x50
	}
	if m.MinBlockLock != 0 {
		i = encodeVarintBep3(dAtA, i, uint64(m.MinBlockLock))
		i--
		dAtA[i] = 0x48
	}
	{
		size := m.MaxSwapAmount.Size()
		i -= size
		if _, err := m.MaxSwapAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintBep3(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size := m.MinSwapAmount.Size()
		i -= size
		if _, err := m.MinSwapAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintBep3(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size := m.FixedFee.Size()
		i -= size
		if _, err := m.FixedFee.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintBep3(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if len(m.DeputyAddress) > 0 {
		i -= len(m.DeputyAddress)
		copy(dAtA[i:], m.DeputyAddress)
		i = encodeVarintBep3(dAtA, i, uint64(len(m.DeputyAddress)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Active {
		i--
		if m.Active {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	{
		size, err := m.SupplyLimit.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintBep3(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.CoinID != 0 {
		i = encodeVarintBep3(dAtA, i, uint64(m.CoinID))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintBep3(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SupplyLimit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SupplyLimit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SupplyLimit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.TimeBasedLimit.Size()
		i -= size
		if _, err := m.TimeBasedLimit.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintBep3(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	n2, err2 := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.TimePeriod, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(m.TimePeriod):])
	if err2 != nil {
		return 0, err2
	}
	i -= n2
	i = encodeVarintBep3(dAtA, i, uint64(n2))
	i--
	dAtA[i] = 0x1a
	if m.TimeLimited {
		i--
		if m.TimeLimited {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	{
		size := m.Limit.Size()
		i -= size
		if _, err := m.Limit.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintBep3(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AtomicSwap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AtomicSwap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AtomicSwap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Direction != 0 {
		i = encodeVarintBep3(dAtA, i, uint64(m.Direction))
		i--
		dAtA[i] = 0x60
	}
	if m.CrossChain {
		i--
		if m.CrossChain {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.Status != 0 {
		i = encodeVarintBep3(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x50
	}
	if m.ClosedBlock != 0 {
		i = encodeVarintBep3(dAtA, i, uint64(m.ClosedBlock))
		i--
		dAtA[i] = 0x48
	}
	if len(m.RecipientOtherChain) > 0 {
		i -= len(m.RecipientOtherChain)
		copy(dAtA[i:], m.RecipientOtherChain)
		i = encodeVarintBep3(dAtA, i, uint64(len(m.RecipientOtherChain)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.SenderOtherChain) > 0 {
		i -= len(m.SenderOtherChain)
		copy(dAtA[i:], m.SenderOtherChain)
		i = encodeVarintBep3(dAtA, i, uint64(len(m.SenderOtherChain)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Recipient) > 0 {
		i -= len(m.Recipient)
		copy(dAtA[i:], m.Recipient)
		i = encodeVarintBep3(dAtA, i, uint64(len(m.Recipient)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintBep3(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Timestamp != 0 {
		i = encodeVarintBep3(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x20
	}
	if m.ExpireHeight != 0 {
		i = encodeVarintBep3(dAtA, i, uint64(m.ExpireHeight))
		i--
		dAtA[i] = 0x18
	}
	if len(m.RandomNumberHash) > 0 {
		i -= len(m.RandomNumberHash)
		copy(dAtA[i:], m.RandomNumberHash)
		i = encodeVarintBep3(dAtA, i, uint64(len(m.RandomNumberHash)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Amount) > 0 {
		for iNdEx := len(m.Amount) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Amount[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBep3(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AssetSupply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AssetSupply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AssetSupply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n3, err3 := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.TimeElapsed, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(m.TimeElapsed):])
	if err3 != nil {
		return 0, err3
	}
	i -= n3
	i = encodeVarintBep3(dAtA, i, uint64(n3))
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.TimeLimitedCurrentSupply.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintBep3(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.CurrentSupply.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintBep3(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.OutgoingSupply.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintBep3(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.IncomingSupply.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintBep3(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintBep3(dAtA []byte, offset int, v uint64) int {
	offset -= sovBep3(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.AssetParams) > 0 {
		for _, e := range m.AssetParams {
			l = e.Size()
			n += 1 + l + sovBep3(uint64(l))
		}
	}
	return n
}

func (m *AssetParam) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovBep3(uint64(l))
	}
	if m.CoinID != 0 {
		n += 1 + sovBep3(uint64(m.CoinID))
	}
	l = m.SupplyLimit.Size()
	n += 1 + l + sovBep3(uint64(l))
	if m.Active {
		n += 2
	}
	l = len(m.DeputyAddress)
	if l > 0 {
		n += 1 + l + sovBep3(uint64(l))
	}
	l = m.FixedFee.Size()
	n += 1 + l + sovBep3(uint64(l))
	l = m.MinSwapAmount.Size()
	n += 1 + l + sovBep3(uint64(l))
	l = m.MaxSwapAmount.Size()
	n += 1 + l + sovBep3(uint64(l))
	if m.MinBlockLock != 0 {
		n += 1 + sovBep3(uint64(m.MinBlockLock))
	}
	if m.MaxBlockLock != 0 {
		n += 1 + sovBep3(uint64(m.MaxBlockLock))
	}
	return n
}

func (m *SupplyLimit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Limit.Size()
	n += 1 + l + sovBep3(uint64(l))
	if m.TimeLimited {
		n += 2
	}
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.TimePeriod)
	n += 1 + l + sovBep3(uint64(l))
	l = m.TimeBasedLimit.Size()
	n += 1 + l + sovBep3(uint64(l))
	return n
}

func (m *AtomicSwap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Amount) > 0 {
		for _, e := range m.Amount {
			l = e.Size()
			n += 1 + l + sovBep3(uint64(l))
		}
	}
	l = len(m.RandomNumberHash)
	if l > 0 {
		n += 1 + l + sovBep3(uint64(l))
	}
	if m.ExpireHeight != 0 {
		n += 1 + sovBep3(uint64(m.ExpireHeight))
	}
	if m.Timestamp != 0 {
		n += 1 + sovBep3(uint64(m.Timestamp))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovBep3(uint64(l))
	}
	l = len(m.Recipient)
	if l > 0 {
		n += 1 + l + sovBep3(uint64(l))
	}
	l = len(m.SenderOtherChain)
	if l > 0 {
		n += 1 + l + sovBep3(uint64(l))
	}
	l = len(m.RecipientOtherChain)
	if l > 0 {
		n += 1 + l + sovBep3(uint64(l))
	}
	if m.ClosedBlock != 0 {
		n += 1 + sovBep3(uint64(m.ClosedBlock))
	}
	if m.Status != 0 {
		n += 1 + sovBep3(uint64(m.Status))
	}
	if m.CrossChain {
		n += 2
	}
	if m.Direction != 0 {
		n += 1 + sovBep3(uint64(m.Direction))
	}
	return n
}

func (m *AssetSupply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.IncomingSupply.Size()
	n += 1 + l + sovBep3(uint64(l))
	l = m.OutgoingSupply.Size()
	n += 1 + l + sovBep3(uint64(l))
	l = m.CurrentSupply.Size()
	n += 1 + l + sovBep3(uint64(l))
	l = m.TimeLimitedCurrentSupply.Size()
	n += 1 + l + sovBep3(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.TimeElapsed)
	n += 1 + l + sovBep3(uint64(l))
	return n
}

func sovBep3(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozBep3(x uint64) (n int) {
	return sovBep3(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBep3
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBep3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBep3
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBep3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetParams = append(m.AssetParams, AssetParam{})
			if err := m.AssetParams[len(m.AssetParams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBep3(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBep3
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AssetParam) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBep3
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AssetParam: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AssetParam: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBep3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBep3
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBep3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoinID", wireType)
			}
			m.CoinID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBep3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CoinID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupplyLimit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBep3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBep3
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBep3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SupplyLimit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Active", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBep3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Active = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeputyAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBep3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBep3
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBep3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeputyAddress = append(m.DeputyAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.DeputyAddress == nil {
				m.DeputyAddress = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FixedFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBep3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBep3
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBep3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FixedFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinSwapAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBep3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBep3
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBep3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinSwapAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSwapAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBep3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBep3
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBep3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxSwapAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinBlockLock", wireType)
			}
			m.MinBlockLock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBep3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinBlockLock |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxBlockLock", wireType)
			}
			m.MaxBlockLock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBep3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxBlockLock |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBep3(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBep3
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SupplyLimit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBep3
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SupplyLimit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SupplyLimit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBep3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBep3
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBep3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Limit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeLimited", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBep3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TimeLimited = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimePeriod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBep3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBep3
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBep3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.TimePeriod, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeBasedLimit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBep3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBep3
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBep3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TimeBasedLimit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBep3(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBep3
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AtomicSwap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBep3
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AtomicSwap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AtomicSwap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBep3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBep3
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBep3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = append(m.Amount, types.Coin{})
			if err := m.Amount[len(m.Amount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RandomNumberHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBep3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBep3
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBep3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RandomNumberHash = append(m.RandomNumberHash[:0], dAtA[iNdEx:postIndex]...)
			if m.RandomNumberHash == nil {
				m.RandomNumberHash = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpireHeight", wireType)
			}
			m.ExpireHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBep3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpireHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBep3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBep3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBep3
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBep3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = append(m.Sender[:0], dAtA[iNdEx:postIndex]...)
			if m.Sender == nil {
				m.Sender = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recipient", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBep3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBep3
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBep3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Recipient = append(m.Recipient[:0], dAtA[iNdEx:postIndex]...)
			if m.Recipient == nil {
				m.Recipient = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderOtherChain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBep3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBep3
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBep3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SenderOtherChain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecipientOtherChain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBep3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBep3
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBep3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecipientOtherChain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClosedBlock", wireType)
			}
			m.ClosedBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBep3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClosedBlock |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBep3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= SwapStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrossChain", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBep3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CrossChain = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			m.Direction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBep3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Direction |= SwapDirection(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBep3(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBep3
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AssetSupply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBep3
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AssetSupply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AssetSupply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncomingSupply", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBep3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBep3
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBep3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.IncomingSupply.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutgoingSupply", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBep3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBep3
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBep3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OutgoingSupply.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentSupply", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBep3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBep3
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBep3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CurrentSupply.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeLimitedCurrentSupply", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBep3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBep3
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBep3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TimeLimitedCurrentSupply.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeElapsed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBep3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBep3
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBep3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.TimeElapsed, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBep3(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBep3
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBep3(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBep3
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBep3
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBep3
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthBep3
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupBep3
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthBep3
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthBep3        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBep3          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupBep3 = fmt.Errorf("proto: unexpected end of group")
)
